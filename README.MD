### Подключаемый модуль для тестирования верстки экранов веб приложений.

#### Настройка конфигурации
Создать класс, имплементирующий IMethodsInjection и реализовать в нём все необходимые методы.

В класс LayoutConfiguration установить объект класса имплементирующего IMethodsInjection и по необходимости переопределить стандартные значения.

Задать используемый на проекте фреймворк (сейчас поддерживается два варианта: Selenium WebDriver и Microsoft Playwright):
```
LayoutConfiguration.INSTANCE.setFrameworkBasedBehavior(new SeleniumFrameworkBehavior()); // для Selenium
LayoutConfiguration.INSTANCE.setFrameworkBasedBehavior(new PlaywrightFrameworkBehavior()); // для Playwright
```
#### Подготовка к запуску теста и запуск
Перед запуском теста верстки необходимо установить один из стандартных размеров экрана. Можно использовать
размеры из enum ScreenSize, либо определить свой класс и передать его в LayoutConfiguration

```
ScreenSizeUtils.setWindowSize(ScreenSize.DESKTOP); // для Selenium
page.setViewportSize(ScreenSize.FULL_HD.getWidth(), ScreenSize.FULL_HD.getHeight()); // для Playwright
```

Далее нужно подготовить список конфигураций для выполнения теста верстки и запустить тест

```
// получаем элемент, внутри которого нужно выполнить тест верстки
WebElement container = driver.findElement(By.xpath("//div[@id = 'container']"));
WebElement element1 = container.findElement(By.xpath("//div[contains(@class, 'element1')]"));
WebElement element2 = container.findElement(By.xpath("//div[contains(@class, 'element2')]"));
WebElement element3 = container.findElement(By.xpath("//div[contains(@class, 'element3')]"));

// добавляем один или более элементов для тестирования
final List<RawDataSet> dataSetList = new ArrayList<>();
dataSetList.add(new RawDataSet("element 1", element1, "TEXT, DECOR"))
           .add(new RawDataSet("element 2", element2, "IMAGE"))
           .add(new RawDataSet("element 3", element3, "ALL"));

// создаём экземпляр экзекутера
final Executor executorDesktop = new Executor(
                dataSetList,
                "scenario_name",
                "path; to; file",
                "CHROME",
                container
        );

// выполняем тест
executorDesktop.execute();
```
При первом запуске будет создан JSON файл со снапшотом полученных со страницы приложения данными.\
Файл будет записан в src/test/resources/data/layouts/CHROME/DESKTOP/path/to/file/scenario_name.json\
в соответствии с данными из примера выше.\
При повторном запуске будет выполнено сравнение данных полученных с экрана с теми, что были ранее записаны в json файл.

#### Доступные варианты проверок

| Тип проверки  | Описание                                                                                                                                                      |
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| POSITION      | Проверка позиции и размера единственного элемента                                                                                                             |
| ALL           | Влючает проверку сразу всех аспектов, перечисленных ниже                                                                                                      |
| TEXT          | Проверка элементов содержащих текст. В снапшот записываются данные о шрифте, оформлении текста и контент                                                      |
| IMAGE         | Проверка элементов <img>. В снапшот записывается относительный путь до изображения либо base64 код                                                            |
| SVG           | Проверка элементов SVG. В снапшот записываются векторные данные со стилями оформления. Если элемент спрятан в shadow dom - будет попытка его вытащить по id   |
| DECOR         | Проверка видимого оформления элементов. Будут найдены все элементы экрана, имеющие видимые стили оформления, такие как border, background, box-shadow, radius |
| PSEUDO_BEFORE | Проверка псевдоэлементов ':before' и ':after'. В снашот записывается контент, цвет шрифта и background стили                                                  |
| PSEUDO_AFTER  |                                                                                                                                                               |

При выполнении любых проверок кроме POSITION, будет выполнен автоматический поиск всех подходящих элементов внутри переданного для проверки элемента.
Данные о всех элементах переданных в один экзекутер будут записаны в единый json файл.
При поиске элементов так же выполняется определение отношения между элементами по типу родитель-потомок.
В последующем это используется для ограничения круга сопоставления элементов при сверке верстки. Сначала сверяются все элементы с самого верхнего уровня (корневые, родительские).
Далее, для сопоставленных элементов выполняется проверка потомков, потом проверка их потомков.

#### Механизм сопоставления элементов
После первого запуска теста выполняются все замеры и полученные данные записываются в json файл.
С каждым последующим запуском будут выполнены все замеры и сравнение данных с записанным ранее json.
В виду того, что единовременно могут проверяться десятки и сотни элементов на одном экране, при этом часть элементов может не на 100% соответствовать размерам и расположению из-за разницы в рендеринге на разных ОС а так же содержать действительные расхождения как по расположению и размерам, так и по специфичным параметрам, тут используется механизм просеивания всех возможных комбинаций элементов.

Сначала из двух набором элементов (актуальные, полученные с экрана сейчас и ожидаемые, полученные из файла json) генерируются все возможные пары элементов.

Далее начинается просеивание:
 - Сначала отсеиваются все пары, содержащие 100% совпадение по всем параметрам. Из общей кучи убираются элементы, которые так же в себе содержат идентифицированные элементы.
 - Далее отсеиваются пары, содержащие идентичные данные и допустимое отклонение в позиции / размере (допустимая волотильность элементов). Так же из общей кучи убираются неактуальные элементы.
 - Далее отсеиваются пары, которые имеют расхождения в данных (оформление, контент), но находятся в одной позиции и имеют аналогичный размер (с учётом допустимой волотильности). Эти элементы записываются в репорт об ошибках. Общая куча очищается от неактульных элементов.
 - Далее отсеиваются пары, имеющие идентичные данные, но различающиеся по позиции / размеру. Эти пары записываются в репорт об ошибках. Куча очищается от неактуальных элементов.
 - Если после просеивания остаются несопоставленные элементы - все они записываются в ошибки по принципу "Элементу на экране не найдено сопоставление из файла" и "Элемент из файла не найден на экране"

Если при просеивании были обнаружены ошибки - на странице браузера будет нарисованы цветные сеточки над элементами в которых найдены ошибки. По этой информации (плюс отчёт об ошибках) можно быстро идентифицировать проблемы с версткой.

#### Ограничения
Из-за сложности идентификации большого количества элементов наложенных друг на друга, на насыщенных интерфейсах рекомендуется делать атомарные проверки (в один тест добавлять один элемент или блок с небольшим количеством элементов) для лучшей стабильности прохождения тестов.
В разных браузерах (Chrome, Firefox, Safari) могут быть значительные расхождения в верстке, поэтому данные о верстках записываются раздельно для разных браузеров.

#### Расширение функциональности
Вы можете использовать свои наборы разрешений, добавлять поддержку других фреймворков, добавлять свои аспекты тестирования.\
Для этого достаточно добавить классы реализации этой функциональности и инжектить их в LayoutConfiguration.\
Интерфейс IScreenSize отвечает за набор размеров экранов. Для примера можно посмотреть реализацию в enum ScreenSize.\
Интерфейс IMeasuringType отвечает за набор способов тестирования верстки. Для примера можно посмотреть реализацию в enum MeasuringType. Важное замечание - типы POSITION и ALL нужно скопировать в своей enum для обеспечения совместимости.\
Интерфейс IRepository отвечает за реализацию тестирования аспекта верстки. Для примера можно посмотреть любые классы, которые наследуют AttributeRepository.
